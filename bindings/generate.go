package main

import (
	"fmt"
	"go/ast"
	"go/format"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	generateFFITypes("raylib.go")
	generateGoFunctions("rcore.go", "rshapes.go")
	generateInitFile("init_windows.go", "raylib.dll", "windows && amd64")
	generateInitFile("init_darwin.go", "libraylib.5.5.0.dylib", "darwin && (amd64 || arm64)")
	generateInitFile("init_unix.go", "libraylib.so.5.5.0", "(unix && !darwin) && amd64")
}

var cTypeMap = map[string]string{
	"void":   "",
	"ptr":    "unsafe.Pointer",
	"cstr":   "*byte",
	"char":   "int8",
	"short":  "int16",
	"cint":   "int32",
	"long":   "int64",
	"uchar":  "uint8",
	"ushort": "uint16",
	"ucint":  "uint32",
	"ulong":  "uint64",
	"float":  "float32",
	"double": "float64",
	"cbool":  "bool",
}

var goTypeMap = map[string]string{
	"unsafe.Pointer": "ptr",
	"string":         "cstr",
	"int8":           "char",
	"int16":          "short",
	"int32":          "cint",
	"int64":          "long",
	"uint8":          "uchar",
	"uint16":         "ushort",
	"uint32":         "ucint",
	"uint64":         "ulong",
	"float32":        "float",
	"float64":        "double",
	"bool":           "cbool",
}

// @todo(judah): this will break bindings on platforms where int/uint aren't 8 bytes
var goArgTypeMap = map[string]string{
	"*byte": "string",
	"bool":  "bool",
	"int8":  "int",
	"int16": "int",
	"int32": "int",
	"int64": "int",

	"uint8":  "uint",
	"uint16": "uint",
	"uint32": "uint",
	"uint64": "uint",

	"float32": "float32",
	"float64": "float64",
}

func generateGoFunctions(filenames ...string) {
	for _, inpath := range filenames {
		fs := token.NewFileSet()
		file, err := parser.ParseFile(fs, inpath, nil, parser.ParseComments)
		if err != nil {
			panic(err)
		}

		var code strings.Builder
		code.WriteString("// Code generated by go generate ./...; DO NOT EDIT.\n\n")
		code.WriteString("package raylib\n\n")
		code.WriteString("import \"unsafe\"\n\n")

		type (
			carg struct {
				ast.Expr
				Name string
			}
			cproc struct {
				CResult ast.Expr
				CArgs   []carg
				GoName  string
				CName   string
				Comment string
			}
		)

		var procs []cproc

		// collect all procedures
		ast.Inspect(file, func(n ast.Node) bool {
			file, ok := n.(*ast.File)
			if !ok {
				return false
			}

			for _, decl := range file.Decls {
				d, ok := decl.(*ast.GenDecl)
				if !ok {
					continue
				}

				for _, spec := range d.Specs {
					val, ok := spec.(*ast.ValueSpec)
					if !ok {
						continue
					}

					var argNames []string
					comment := strings.TrimSpace(val.Comment.Text())
					if strings.Contains(comment, "::") {
						parts := strings.Split(comment, "::")
						comment = strings.TrimSpace(parts[1])
						argNames = strings.Split(parts[0], ",")
					}

					cName := val.Names[0].Name
					prepCall := val.Values[0].(*ast.CallExpr)

					goName := prepCall.Args[1].(*ast.BasicLit).Value
					goName = goName[1 : len(goName)-1]

					var cArgs []carg
					if len(prepCall.Args) > 2 {
						for i, arg := range prepCall.Args[2:] {
							var name string
							if len(argNames) > 0 && i < len(argNames) {
								name = argNames[i]
							}
							cArgs = append(cArgs, carg{Expr: arg, Name: name})
						}
					}

					procs = append(procs, cproc{
						Comment: comment,
						GoName:  goName,
						CName:   cName,
						CResult: prepCall.Args[0],
						CArgs:   cArgs,
					})
				}
			}

			// generate go procedures
			for _, proc := range procs {
				var (
					body   strings.Builder
					goArgs strings.Builder
					goRes  strings.Builder
				)

				var resGoType string
				if unary, ok := proc.CResult.(*ast.UnaryExpr); ok {
					ident := unary.X.(*ast.Ident)
					resGoType, ok = cTypeMap[ident.Name]
					if !ok {
						if ident.Name[0] != 't' {
							panic("result type didn't exist: " + ident.Name)
						}

						resGoType = ident.Name[1:]
					}
				}

				if len(resGoType) != 0 {
					fmt.Fprintf(&goRes, "(res %s)", resGoType)
				}

				for i, arg := range proc.CArgs {
					var ident string
					if unary, ok := arg.Expr.(*ast.UnaryExpr); ok {
						ident = unary.X.(*ast.Ident).Name
					} else {
						ident = arg.Expr.(*ast.Ident).Name
					}

					goType, ok := cTypeMap[ident]
					if !ok {
						if ident[0] != 't' {
							panic("unknown argument type: " + ident)
						}

						goType = ident[1:]
					}

					if t, ok := goArgTypeMap[goType]; ok {
						goType = t
					}

					if strings.HasSuffix(goType, "Ptr") {
						goType = "*" + goType[:len(goType)-3]
					}

					argName := arg.Name
					if len(argName) == 0 {
						argName = fmt.Sprintf("arg%d", i)
					}

					fmt.Fprintf(&goArgs, "%s %s", argName, goType)
					if i < len(proc.CArgs)-1 {
						goArgs.WriteString(", ")
					}

					procOrCast := goType
					if goType == "string" {
						procOrCast = "tocstring"
					} else if goType[0] == '*' {
						procOrCast = fmt.Sprintf("(%s)", goType)
					} else if goType == "int" {
						procOrCast = "int64"
					} else if goType == "uint" {
						procOrCast = "uint64"
					} else {
						switch goType {
						case "PixelFormat", "ConfigFlags", "CameraProjection", "NPatchLayout":
							procOrCast = "uint64"
						}
					}

					fmt.Fprintf(&body, "\ta%d := %s(%s)\n", i, procOrCast, argName)
				}

				voidResult := false
				needsPointer := false
				switch resGoType {
				case "void", "":
					voidResult = true
					fmt.Fprintf(&body, "\t%s.void", proc.CName)
				case "bool":
					fmt.Fprintf(&body, "\tres = %s.bool", proc.CName)

				case "uint8", "uint16", "uint32", "uint64",
					"int8", "int16", "int32", "int64":
					fmt.Fprintf(&body, "\tres = %s.%s", proc.CName, resGoType)

				default:
					needsPointer = true
					fmt.Fprintf(&body, "\t%s.call", proc.CName)
				}

				body.WriteByte('(')

				if !voidResult && needsPointer {
					fmt.Fprintf(&body, "unsafe.Pointer(&res)")
					if len(proc.CArgs) != 0 {
						body.WriteString(", ")
					}
				}

				for i := range proc.CArgs {
					fmt.Fprintf(&body, "unsafe.Pointer(&a%d)", i)
					if i < len(proc.CArgs)-1 {
						body.WriteString(", ")
					}
				}
				body.WriteString(")")

				if !voidResult {
					fmt.Fprintf(&body, "\n\treturn res")
				}

				rep := strings.NewReplacer(
					"$Description", proc.Comment,
					"$GoName", proc.GoName,
					"$Args", goArgs.String(),
					"$Result", goRes.String(),
					"$Body", body.String(),
				)

				const funcTemplate = `
				// $Description
				func $GoName($Args) $Result {
					$Body
				}
				`

				code.WriteString(rep.Replace(funcTemplate))
			}

			src, err := format.Source([]byte(code.String()))
			if err != nil {
				panic(err)
			}

			outpath := fmt.Sprintf("%s.gen.go", inpath[:len(inpath)-len(filepath.Ext(inpath))])
			if err := os.WriteFile(outpath, src, 0664); err != nil {
				panic(err)
			}

			return true
		})
	}
}

func generateFFITypes(filenames ...string) {
	for _, inpath := range filenames {
		fs := token.NewFileSet()
		file, err := parser.ParseFile(fs, inpath, nil, parser.ParseComments)
		if err != nil {
			panic(err)
		}

		var code strings.Builder
		code.WriteString("// Code generated by go generate ./...; DO NOT EDIT.\n\n")
		code.WriteString("package raylib\n\n")
		code.WriteString("import \"github.com/judah-caruso/ffi-embeded\"\n\n")

		code.WriteString("var (\n")
		for _, decl := range file.Decls {
			d, ok := decl.(*ast.GenDecl)
			if !ok {
				continue
			}

			if d.Tok != token.TYPE {
				continue
			}

			for _, spec := range d.Specs {
				ts, ok := spec.(*ast.TypeSpec)
				if !ok {
					continue
				}

				tName := "t" + ts.Name.Name

				if ident, ok := ts.Type.(*ast.Ident); ok {
					cType, ok := goTypeMap[ident.Name]
					if !ok {
						cType = "t" + ident.Name
					}

					fmt.Fprintf(&code, "\t%s = %s\n", tName, cType)
				} else {
					s := ts.Type.(*ast.StructType)
					if s.Incomplete {
						panic("type " + ts.Name.Name + " was incomplete")
					}

					fmt.Fprintf(&code, "\t%s = ffi.NewType(", tName)

					for i, field := range s.Fields.List {
						var ft string

						switch t := field.Type.(type) {
						case *ast.Ident:
							ft = t.Name
						case *ast.SelectorExpr:
							if t.Sel.Name != "Pointer" {
								panic(fmt.Sprintf("unknown selector: %s", t.Sel.Name))
							}

							ft = "unsafe.Pointer"
						case *ast.StarExpr:
							ft = "unsafe.Pointer"
						case *ast.ArrayType:
							ft = "unsafe.Pointer"

						default:
							panic(fmt.Sprintf("unhandled: %T", t))
						}

						cType, ok := goTypeMap[ft]
						if !ok {
							cType = "t" + ft
						}

						cType = "&" + cType

						code.WriteString(cType)

						if i < len(s.Fields.List)-1 {
							code.WriteString(", ")
						}
					}

					code.WriteString(")\n")
				}

				fmt.Fprintf(&code, "\tt%sPtr = ptr\n", ts.Name)
			}
		}
		code.WriteString(")\n\n")

		src, err := format.Source([]byte(code.String()))
		if err != nil {
			panic(err)
		}

		outpath := fmt.Sprintf("%s.gen.go", inpath[:len(inpath)-len(filepath.Ext(inpath))])
		if err := os.WriteFile(outpath, src, 0664); err != nil {
			panic(err)
		}
	}
}

func generateInitFile(filename string, libpath string, gobuild string) {
	b, err := os.ReadFile(libpath)
	if err != nil {
		return
	}

	var code strings.Builder
	code.WriteString("// Code generated by go generate ./...; DO NOT EDIT.\n\n")
	code.WriteString("//go:build " + gobuild + "\n")
	code.WriteString("package raylib\n\n")

	code.WriteString("// This will be used as the temporary filename on startup\n")
	fmt.Fprintf(&code, "const libName = %q\n\n", libpath)

	fmt.Fprintf(&code, "// The data of %s\n", libpath)
	code.WriteString("const libData = \"")

	for _, byt := range b {
		bstr := fmt.Sprintf("%#02x", byt)
		fmt.Fprintf(&code, "\\x%s", bstr[2:])
	}

	code.WriteString("\"\n")

	if err := os.WriteFile(filename, []byte(code.String()), 0664); err != nil {
		panic(err)
	}
}
